
task.wait(math.random(1,11)/10)
if not getgenv().rakdotloaded then
    getgenv().rakdotloaded = true
else
    return
end

function SCRIPT()

local sucka,reska = pcall(function()

local WL = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/WL'))()
local access = false
for i,v in ipairs(WL) do
    if v:lower() == game.Players.LocalPlayer.Name:lower() then
        access = true
        break
    end
end
if not access then
    game.Players.LocalPlayer:Kick('buy whitelist bro ez ez ez ez ez ze ez ezez eze ze')
    while true do
        warn('nani')
    end
    else
    warn('WL!')
end

wait(5)
function loadscript_amp()
local lvl = game.Players.LocalPlayer:WaitForChild('Level')
warn('KEE 1')
if not lvl then
    wait(3)
    lvl = game.Players.LocalPlayer:FindFirstChild('Level')
    if not lvl then
        while wait(3) do
            game:GetService("TeleportService"):Teleport(3260590327)
        end
    end
end
warn('KEE 2')
local towers = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/roblox%20tds%20towers%20json'))()
local totowers42 = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/roblox%20tds%20cliff%20towers'))()
local huesositowers52 = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/roblox%20tds%20locked%20towers'))()
local plan = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/roblox%20tds%20towers%20json'))()
warn('KEE 3')
for i,v in {plan,towers} do
for tower,data in pairs(v) do
    local ct = totowers42[tower]
    if ct == 1 then
        data.Typerakdot = 'Cliff'
    else
        data.Typerakdot = 'Ground'
    end
    data.Namerakdot = tower
    local prev =  (data['Properties'] and data['Properties']['Price'] and data['Properties']['Price']['PreviewText']) or nil
    if prev then
        local firstNumber = prev.match(prev, "%d+")
        if firstNumber then
            data.LVLTOBUYrakdot = tonumber(firstNumber)
        else
            data.LVLTOBUYrakdot = 0
        end
    else
        data.LVLTOBUYrakdot = 0
    end
end
end
warn('KEE 4')
local lp = game.Players.LocalPlayer.Name
local dif
if lvl.Value >= 30 then
    dif = 'Fallen'
elseif lvl.Value >= 15 then
    dif = 'Molten'
elseif lvl.Value >= 5 then
    dif = 'Intermediate'
else
    dif = 'Easy'
end
local cfg = {
    MM = {
        difficulty = dif,
        Count = 1,
        Mode = 'survival'
    }
}
function startgame()
    wait(2.5)
    local args = {
        [1] = "Multiplayer",
        [2] = "v2:start",
        [3] = {
            ["difficulty"] = cfg.MM.difficulty,
            ["count"] = cfg.MM.Count,
            ["mode"] = cfg.MM.Mode
        }
    }
    warn('KEE match')
    spawn(function ()
        wait(7.5)
        while wait(1) do warn('KEE teleport') 
            game:GetService("TeleportService"):Teleport(3260590327)
        end
    end)
    game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
end

warn('KEE 5')
function handOhand(async)
    if async then
        spawn(function()
            handOhand()
        end)
    end
        local hand = {
        'Soldier', 'Sniper', 'Militant', 'Scout'
    }
    for i,v in ipairs({'Unequip','Equip'}) do
        for ii,tower in ipairs(hand) do
            local args = {
                [1] = "Inventory",
                [2] = v,
                [3] = "tower",
                [4] = tower
            }
            
            game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
            task.wait(0.15)
        end
        if i == 1 then
        wait(1)
        end
    end
end

local function coins()
    return game.Players.LocalPlayer.Coins.Value
end

local buy_things_allowed = true

--local plan = {
    --[1] = {Name = 'Soldier', Price = 400};
    --[2] = {Name = 'Minigunner', Price = 8000};
    --[3] = {Name = 'Farm', Price = 2500};
    --[4] = {Name = 'Ranger', Price = 12000};
    --[5] = {Name = 'Commander', Price = 4000};
    --[6] = {Name = 'DJ Booth', Price = 5000};
--}

local owned_troops = {}
local current_hand = {}
local not_owned_troops = {}
warn('KEE 6')
game:GetService("Players").LocalPlayer.PlayerGui:WaitForChild('Interface')
wait(2)
if not game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild('Interface') then
    startgame()
    while wait(3) do
    end
end

handOhand()
wait(1)
warn('KEE 7')
for i,v in ipairs(game:GetService("Players").LocalPlayer.PlayerGui.Interface.Root.Inventory.View.Frame.Frame.Frame.Layout.Panel.InventoryScroller:GetDescendants()) do
    local spl = v.Name:split(":")
    if spl then
        if #spl == 2 then
            spl[2] = tostring(spl[2])
            spl[1] = tostring(spl[1])
            if spl[1] == 'Troop' then
                local states = v.States
                if states.Equipped.Visible then print(5)
                    current_hand[spl[2]] = 1
                    owned_troops[spl[2]] = 1
                else
                    if states.Locked.Visible then
                        not_owned_troops[spl[2]] = 1
                    else
                        owned_troops[spl[2]] = 1
                    end
                end
            end
        end
    end
end
warn('KEE 8')
for i,v in pairs(owned_troops) do
    print('owned: ',i)
end
for sa=1,25 do
for i,v in pairs(plan) do
    if table.find(huesositowers52,v.Namerakdot) or owned_troops[v.Namerakdot] or not (v['Properties'] and v['Properties']['Price'] and v['Properties']['Price']['Value']) then
        plan[i] = nil
        print('removing ',v.Namerakdot)
    elseif v.LVLTOBUYrakdot > lvl.Value then
        plan[i] = nil
        print('removingLVL ',v.Namerakdot)
    end
end
end
for i,v in pairs(plan) do
    print('plan: ',v.Namerakdot)
end
warn('KEE 9')
function checkplan()
    if game.Players.LocalPlayer.Level.Value >= 25 then
        game:GetService("TeleportService"):Teleport(3260590327)
    end
    if buy_things_allowed then
        for i,v in pairs(plan) do
            if not v['Properties'] or not v['Properties']['Price'] or not v['Properties']['Price']['Value'] then
                continue
            end
            if coins() >= v.Properties.Price.Value then
            makefolder('rakdot') 
            local lp = game.Players.LocalPlayer.Name
            makefolder('rakdot\\'..lp)
            writefile('rakdot\\'..lp..'\\buy.tower.rakdot', i)
            --writefile('rakdot\\'..lp..'\\RETURN.rakdot', 'yo yo')
            warn('buying ',i)
            wait(0.1)
            game:GetService("TeleportService"):Teleport(3260590327)
            return true
            end
            task.wait()
        end
    end     
end

spawn(function()
    while wait(0.25) do
        if checkplan() then break end
    end
end)
warn('KEE 10')
local tower_list = {}

local the
local ptf
local lowest = 10
for i,v in ipairs(workspace.IntermissionLobby.Boards:GetChildren()) do
    local bal = 0
    for e,ve in ipairs(v.Hitboxes.Bottom.MapDisplay.Rating:GetChildren()) do
        if ve:IsA('ImageLabel') then
            if ve.Visible then
                bal+=1
            end
        end
    end
    if bal < lowest then
        print(bal)
        lowest = bal
        the = v.Hitboxes.Bottom.MapDisplay.Title.Text
        ptf = v.Hitboxes.VotePlatform.Position
    end
end
warn('KEE 11')
local args = {
    [1] = "LobbyVoting",
    [2] = "Vote",
    [3] = the,
    [4] = ptf
}

game:GetService("ReplicatedStorage").RemoteEvent:FireServer(unpack(args))

local args = {
    [1] = "LobbyVoting",
    [2] = "Ready"
}
game:GetService("ReplicatedStorage").RemoteEvent:FireServer(unpack(args))

wait(3)
warn('KEE 12')
if #game:GetService("Players").LocalPlayer.PlayerGui:GetChildren() < 30 then
    startgame()
end
warn('KEE 13')
workspace.NPCs.ChildAdded:Once(function(ch)
wait(0.5)
start = ch:WaitForChild('Torso')
print(start.Position)
end)

while not start do wait() end
start = {Position = start.Position} -- to be statistic
warn('KEE 114444444444')
local pretend1 = workspace.Map.Road:GetChildren()
local pretend2 = workspace.Boundaries:GetDescendants()
if #pretend1 < #pretend2 then
    doroga = workspace.Boundaries
else
    doroga = workspace.Map.Road
end


warn(#doroga:GetChildren())

local map, target_lvl

local pert = Instance.new("Part")
pert.Size = Vector3.new(0.3, 100, 0.3)
pert.Transparency = 0.3
pert.Anchored = true
pert.CanTouch = false
pert.CanCollide = false
pert.Parent = workspace
pert.Color = Color3.fromRGB(255, 0, 0)

local psyh_towers = workspace.Towers
--local towers = {
    --['Soldier'] = {['Name']='Soldier',['Cost']=350,['Type']='Ground'},
    --['Sniper'] = {['Name']='Sniper',['Cost']=300,['Type']='Cliff'},
    --['Minigunner'] = {['Name']='Minigunner',['Cost']=1850,['Type']='Ground'},
    --['Farm'] = {['Name']='Farm',['Cost']=250,['Type']='Ground'},
    --['Ranger'] = {['Name']='Ranger',['Cost']=12000,['Type']='Cliff'},
    --['Commander'] = {['Name']='Commander',['Cost']=4000,['Type']='Ground'},
    --['DJ Booth'] = {['Name']='DJ Booth',['Cost']=5000,['Type']='Ground'},
--}

local skips = {Cliff = 0, Ground = 0}

local first
local minDist = math.huge
for i, v in ipairs(doroga:GetChildren()) do
    if v:IsA('BasePart') then
        v.CanCollide = true
        v.CanTouch = true
        v.CanQuery = true
        v.Size += Vector3.new(0.1, 0.1, 0.1)
        local dist = (v.Position - start.Position).Magnitude
        if dist < minDist then
            minDist = dist
            first = v
        end
    end
end

local firstC
local minDist = math.huge

for i, v in ipairs(workspace.Cliff:GetChildren()) do
    if v:IsA('BasePart') then
        v.CanCollide = true
        v.CanTouch = true
        v.CanQuery = true
        v.Size += Vector3.new(0.1, 0.1, 0.1)
        local dist = (v.Position - start.Position).Magnitude
        if dist < minDist then
            minDist = dist
            firstC = v
        end
    end
end

local function findMostPopularName(objectList)
    if not objectList or #objectList == 0 then
        return nil, "Object list is empty."
    end
    local nameCounts = {}
    for _, obj in ipairs(objectList) do
        if obj and obj.Name then
            local name = tostring(obj.Name)
            nameCounts[name] = (nameCounts[name] or 0) + 1
        end
    end
    if next(nameCounts) == nil then
        return nil, "No objects in the list have a 'Name' property."
    end
    local mostPopularName = nil
    local maxCount = 0
    for name, count in pairs(nameCounts) do
        if count > maxCount then
            maxCount = count
            mostPopularName = name
        end
    end
    return mostPopularName, nil
end

local basename,err = findMostPopularName(doroga:GetChildren())

local worked = {
    first
}

local road = {
    [1] = first
}

local cur = first
    breaking = false
    while task.wait() do
        if breaking then print(1)
            break
        end
        if cur == bcur then print(2)
            break
        end
        cur.Touched:Connect(function() end)
        wait()
        warn(cur)
        local touches = cur:GetTouchingParts()
        for huhu,touch in ipairs(touches) do
            print(touch)
            if (not touch:IsDescendantOf(doroga)) or touch.Name ~= basename then 
                if huhu >= #touches then
                    breaking = true
                    break
                end
                continue
            end
            local isworked = false
            for i,v in ipairs(worked) do
                if v == touch then
                    isworked = true
                end
            end
            table.insert(worked,touch)
            if not isworked then
                print('choised ',touch)
                road[#road+1] = touch
                bcur = cur
                cur = touch
                break
            else
                if huhu >= #touches then
                    breaking = true
                    break
                end
            end
        end
    end
    
    warn(#road)

local placemap = { -- manipulate it lol

}

function place(sekeps)

    local function getExpandedCorners(part, expansion)
        local size = part.Size
        local cf = part.CFrame
        local newHalfX = (size.X / 2) + expansion
        local newHalfZ = (size.Z / 2) + expansion
        local topLeftLocal = Vector3.new(-newHalfX, 0, -newHalfZ)
        local bottomRightLocal = Vector3.new(newHalfX, 0, newHalfZ)
        local worldTopLeft = cf:PointToWorldSpace(topLeftLocal)
        local worldBottomRight = cf:PointToWorldSpace(bottomRightLocal)
        return worldTopLeft, worldBottomRight
    end
    
    local function bal()
        local temp123 = game:GetService("Players").LocalPlayer.PlayerGui.ReactUniversalHotbar.Frame.values.cash.amount.Text:gsub('%$',''):gsub(',','')
        local cash = tonumber(temp123)
        return cash
    end

    local tower = towers[placemap[1]]
    if not tower then
        warn('no tower...........')
        return
    end

    if tower.Typerakdot == 'Cliff' then
        local cliffs = workspace.Cliff:GetChildren()
        for i,v in ipairs(cliffs) do
            if v:IsA('BasePart') then
                v.CanCollide = true
                v.CanTouch = true
                v.CanQuery = true
            else
                table.remove(cliffs, table.find(cliffs, v))
            end
        end
        table.sort(cliffs, function(a, b)
            return (a.Position - start.Position).Magnitude < (b.Position - start.Position).Magnitude
        end)
        n=0
        local kur = 0
        local startedwith = map[#psyh_towers:GetChildren()]
        local skip_done = false
        for i,cliff in ipairs(cliffs) do
            if cliff:IsA('BasePart') then

                local point1, point2 = getExpandedCorners(cliff, 1)
                local minX, maxX = math.min(point1.X, point2.X), math.max(point1.X, point2.X)
                local minZ, maxZ = math.min(point1.Z, point2.Z), math.max(point1.Z, point2.Z)
                local totalX = math.floor((maxX - minX) / 0.1) + 1
                local totalZ = math.floor((maxZ - minZ) / 0.1) + 1
                local totalPoints = totalX * totalZ

                local startX, startZ = minX, minZ

            -- If we still need to skip
            if not skip_done and sekeps[tower.Typerakdot] > 0 then
                local to_skip = math.min(sekeps[tower.Typerakdot], totalPoints)
                -- Calculate how many full rows to skip
                local rows_to_skip = math.floor(to_skip / totalZ)
                local remain_to_skip = to_skip % totalZ

                startX = minX + rows_to_skip * 0.1
                startZ = minZ + remain_to_skip * 0.1

                kur = kur + to_skip
                sekeps[tower.Typerakdot] = sekeps[tower.Typerakdot] - to_skip
                if sekeps[tower.Typerakdot] <= 0 then
                    skip_done = true
                end
            end

            for x = startX, maxX, 0.1 do
                for z = (x == startX and startZ or minZ), maxZ, 0.1 do
                    --kur += 1
                    -- No need to check kur < sekeps[tower.Typerakdot] anymore, as we already skipped efficiently
                    if tower.Stats.Default.Defaults.Price > bal() then
                        warn('катастрофа')
                        --katas
                        return
                    end
                    local bleh = game:GetService("Players").LocalPlayer.PlayerGui.ReactUniversalHotbar.Frame.values.placement.amount.Text:split('/')
                    local placed = tonumber(bleh[1])
                    local maxplace = tonumber(bleh[2])
                    if placed >= maxplace then
                        warn('katastrofa')
                        --katas
                        return
                    end

                    local trops_amount = #psyh_towers:GetChildren()
                    local tower = towers[placemap[1]]
                    if not tower then
                        return
                    end
                    
                    if map[trops_amount] ~= startedwith then
                        target_lvl = map[trops_amount]
                        warn('targetEING ! level: ',target_lvl)
                        print('katastrofa')
                        --katas
                        return
                    end

                    skips[tower.Typerakdot] += 1

                    n += 1
                    if n >= 50 then
                        task.wait()
                        n = 0
                    end print(4)
                    local coord = Vector3.new(x, cliff.Position.Y+10.5, z)
                    print('pr crd ',coord)
                    pert.Position = coord
                    local part, position, normal, material = workspace:FindPartOnRay(Ray.new(coord, Vector3.new(0,-100,0)))
                    warn(part)
                    local ray = {Instance = part, Position = position}
                    if ray and part then
                    print('ray: ',ray)
                        if ray.Instance:IsDescendantOf(workspace.Cliff) then
                            print('can place CLEFFOO yoy oyo yoy o ',ray.Position, ' and the path is ', cliff.Position)
                            local ray = ray
                            coroutine.wrap(function()
                            local tower = tower
                            local args = {
                                [1] = "Troops",
                                [2] = "Pl\208\176ce", --its right
                                [3] = {
                                    ["Rotation"] = CFrame.new(0, 0, 0) * CFrame.Angles(-0, 0,-0),
                                    ["Position"] = ray.Position
                                },
                                [4] = tower.Namerakdot
                            }
        
                            local res = game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
                            if tostring(res) == 'Default' then
                                if tower_list[tower.Namerakdot] then
                                    tower_list[tower.Namerakdot] = tower_list[tower.Namerakdot] + 1
                                else
                                    tower_list[tower.Namerakdot] = 1
                                end
                            end
                        end)()
                        --return
                        end
                    end
                end
            end

            end
        end
        warn('NO CLIFFS ANYMORE')
        cliffs = false
        return
    elseif tower.Typerakdot == 'Ground' then
    
        n=0
        local kur = 0
        local startedwith = map[#psyh_towers:GetChildren()]
        local skip_done = false

        for index, path in ipairs(road) do
            local point1, point2 = getExpandedCorners(path, 4)
            local minX, maxX = math.min(point1.X, point2.X), math.max(point1.X, point2.X)
            local minZ, maxZ = math.min(point1.Z, point2.Z), math.max(point1.Z, point2.Z)
            local totalX = math.floor((maxX - minX) / 0.1) + 1
            local totalZ = math.floor((maxZ - minZ) / 0.1) + 1
            local totalPoints = totalX * totalZ

            local startX, startZ = minX, minZ

            -- If we still need to skip
            if not skip_done and sekeps[tower.Typerakdot] > 0 then
                local to_skip = math.min(sekeps[tower.Typerakdot], totalPoints)
                -- Calculate how many full rows to skip
                local rows_to_skip = math.floor(to_skip / totalZ)
                local remain_to_skip = to_skip % totalZ

                startX = minX + rows_to_skip * 0.1
                startZ = minZ + remain_to_skip * 0.1

                kur = kur + to_skip
                sekeps[tower.Typerakdot] = sekeps[tower.Typerakdot] - to_skip
                if sekeps[tower.Typerakdot] <= 0 then
                    skip_done = true
                end
            end


            for x = startX, maxX, 0.1 do
                for z = (x == startX and startZ or minZ), maxZ, 0.1 do
                    --kur += 1
                    -- No need to check kur < sekeps[tower.Typerakdot] anymore, as we already skipped efficiently
                    if tower.Stats.Default.Defaults.Price > bal() then
                        warn('катастрофа')
                        --katas
                        return
                    end
                    local bleh = game:GetService("Players").LocalPlayer.PlayerGui.ReactUniversalHotbar.Frame.values.placement.amount.Text:split('/')
                    local placed = tonumber(bleh[1])
                    local maxplace = tonumber(bleh[2])
                    if placed >= maxplace then
                        warn('katastrofa')
                        --katas
                        return
                    end

                    if game:GetService("Players").LocalPlayer.PlayerGui.ReactGameRewards.Frame.gameOver.Visible then
                        return
                    end

                    local trops_amount = #psyh_towers:GetChildren()
                    local tower = towers[placemap[1]]
                    if not tower then
                        return
                    end
                    
                    if map[trops_amount] ~= startedwith then
                        target_lvl = map[trops_amount]
                        warn('targetEING ! level: ',target_lvl)
                        print('katastrofa')
                        --katas
                        return
                    end

                    skips[tower.Typerakdot] += 1

                    n += 1
                    if n >= 50 then
                        task.wait()
                        n = 0
                    end print(4)
                    local coord = Vector3.new(x, path.Position.Y+10.5, z)
                    print('pr crd ',coord)
                    pert.Position = coord
                    local part, position, normal, material = workspace:FindPartOnRay(Ray.new(coord, Vector3.new(0,-100,0)))
                    warn(part)
                    local ray = {Instance = part, Position = position}
                    if ray and part then
                    print('ray: ',ray)
                        if ray.Instance:IsDescendantOf(workspace.Ground) then
                            print('can place yoy oyo yoy o ',ray.Position, ' and the path is ', path.Position)
                            local ray = ray
                            coroutine.wrap(function()
                            local tower = tower
                            local args = {
                                [1] = "Troops",
                                [2] = "Pl\208\176ce", --its right
                                [3] = {
                                    ["Rotation"] = CFrame.new(0, 0, 0) * CFrame.Angles(-0, 0,-0),
                                    ["Position"] = ray.Position
                                },
                                [4] = tower.Namerakdot
                            }
        
                            local res = game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
                            if tostring(res) == 'Default' then
                                if tower_list[tower.Namerakdot] then
                                    tower_list[tower.Namerakdot] = tower_list[tower.Namerakdot] + 1
                                else
                                    tower_list[tower.Namerakdot] = 1
                                end
                            end
                        end)()
                        --return
                        end
                    end
                end
            end
        end
    end
end

local function lvl(tower)
    local objects = tower.Upgrades:GetChildren()
    local sorted = table.create(#objects)
    for i, obj in ipairs(objects) do
        sorted[i] = obj
    end
    table.sort(sorted, function(a, b)
        return tonumber(a.Name) < tonumber(b.Name)
    end)

    for i, obj in ipairs(sorted) do
        local allTransparent = true

        for _, desc in ipairs(obj:GetDescendants()) do
            if desc:IsA("BasePart") and desc.Transparency < 1 then
                allTransparent = false
                break
            end
        end

        if allTransparent then
            if i > 1 then
                return sorted[i - 1].Name
            else
                return nil
            end
        end
    end

    if #sorted > 0 then
        return tonumber(sorted[#sorted].Name)
    else
        return nil
    end
end

function upg(tower)
    warn('upg')
    local args = {
        [1] = "Troops",
        [2] = "Upgrade",
        [3] = "Set",
        [4] = {
            ["Troop"] = tower,
            ["Path"] = 1
        }
    }
    game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
end

target_lvl = 0

function do_upg(levels,minLevel)
    warn('Good time for upg!')
    for i,v in ipairs(psyh_towers:GetChildren()) do
        if levels[i] < target_lvl then
            warn('checks level: ',levels[i])
            warn('target level: ',target_lvl)
            for ie = levels[i], target_lvl-1 do
                upg(v)
                wait(0.1)
            end
        end
    end
end

function do_place(cash)
    print('do place')
    print(placemap[1])
    print(towers[placemap[1]])
    print(towers[placemap[1]].Stats.Default.Defaults.Price)
    if cash >= towers[placemap[1]].Stats.Default.Defaults.Price then
        place(skips)
        wait(3)
    end
end

psyh_towers.ChildAdded:Connect(function(tower)
    if target_lvl == 0 then
        return
    end
    for i = 1, target_lvl do
        upg(tower)
        wait(0.1)
    end
end)

map = {
    [0] = 0;
    [1] = 0;
    [2] = 0;
    [3] = 0;
    [4] = 0;
    [5] = 1;
    [6] = 1;
    [7] = 1;
    [8] = 1;
    [9] = 1;
    [10] = 2;
    [11] = 2;
    [12] = 2;
    [13] = 2;
    [14] = 2;
    [15] = 2;
    [16] = 2;
    [17] = 2;
    [18] = 2;
    [19] = 2;
    [20] = 2;
    [21] = 2;
    [22] = 2;
    [23] = 3;
    [24] = 3;
    [25] = 3;
    [26] = 3;
    [27] = 3;
    [28] = 3;
    [29] = 3;
    [30] = 3;
    [31] = 3;
    [32] = 3;
    [33] = 3;
    [34] = 3;
    [35] = 3;
    [36] = 3;
    [37] = 3;
    [38] = 3;
    [39] = 3;
    [40] = 4;
}

coroutine.wrap(function()
    while wait(0.5) do
        
        if game:GetService("Players").LocalPlayer.PlayerGui.ReactGameRewards.Frame.gameOver.Visible then

            if checkplan() then break end

            wait(2)
            
           startgame()

           break
            
        end
    end
end)()
warn('hand:')
for i,v in pairs(current_hand) do
print(i,v)
end
local thefirst = ((current_hand['Militant'] and 'Militant') or false) or ((current_hand['Soldier'] and 'Soldier') or false) or 'Scout'
local target_place = {-- v target amout, vv when its coming
    [tostring(thefirst)] = {v=13,vv=0};
    ['Sniper'] = {v=17,vv=3};
}
while task.wait(1) do
    local bal = game:GetService("Players").LocalPlayer.PlayerGui.ReactUniversalHotbar.Frame.values.cash.amount.Text:gsub('%$',''):gsub(',','')
    local cash = tonumber(bal)
    local trops_amount = #psyh_towers:GetChildren()
    local bleh = game:GetService("Players").LocalPlayer.PlayerGui.ReactUniversalHotbar.Frame.values.placement.amount.Text:split('/')
    local placed = tonumber(bleh[1])
    local maxplace = tonumber(bleh[2])
    local levels = {}
    for i,v in ipairs(psyh_towers:GetChildren()) do
        local got = lvl(v)
        if got then
            levels[i] = tonumber(got)
        end
    end
    local minLevel = 999
    for _, level in ipairs(levels) do
        warn('level: ',level)
        if level and level < minLevel then
            minLevel = level
        end
    end
    if minLevel == 999 then
        minLevel = 0
    end
    if game:GetService("Players").LocalPlayer.PlayerGui.ReactGameRewards.Frame.gameOver.Visible then
        wait(4)
        startgame()
    end
    warn('tropps amount: ',trops_amount)
    warn('mapped: ',map[trops_amount])
    warn('minLevel: ',minLevel)
    if trops_amount < 30 and not game:GetService("Players").LocalPlayer.PlayerGui.ReactGameRewards.Frame.gameOver.Visible then
       
    local args = {
        [1] = "Voting",
        [2] = "Skip"
    }
    game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
    elseif game:GetService("Players").LocalPlayer.PlayerGui.ReactGameRewards.Frame.gameOver.Visible then
        wait(4)
        startgame()
    end
    if (minLevel < map[trops_amount]) then
        target_lvl = map[trops_amount]
        warn('targetEING ! level: ',target_lvl)
        do_upg(levels,minLevel)
    elseif placed < maxplace then
        local target = target_place
        local current = tower_list

        local maxRatio = -math.huge
        local worstKey = nil

        for key, targetValue in pairs(target) do
            if targetValue.vv <= #psyh_towers:GetChildren() then
                local currentValue = current[key] or 0
                local diff = math.clamp((targetValue.v - currentValue) / targetValue.v, 0, 1) -- clamp от 0 до 1
                if diff > maxRatio then
                    maxRatio = diff
                    worstKey = key
                end
            end
        end
        if worstKey == nil then
            warn('no towers to place, but why?')
            return
        end
        warn('worstKey: ',worstKey,' and the ratio is ',maxRatio)
        placemap = {
            worstKey
        }
        do_place(cash)
        wait(1.5)
    end
end
end
function loadscript_ab()

local things = {
    [1] = Vector3.new(-8.11595630645752, 1.000002384185791, 12.638731956481934),
    [2] = Vector3.new(-8.012102127075195, 1.000002384185791, 6.626697540283203),
    [3] = 'force level 1',
    [4] = Vector3.new(-4.981342792510986, 1.000002384185791, 6.620789527893066),
    [5] = Vector3.new(-5.043467044830322, 1.000002384185791, 12.735904693603516),
    [6] = 'force level 2',
    [7] = Vector3.new(0.49546515941619873, 1.000002384185791, 7.539355278015137), 
    [8] = Vector3.new(0.09491634368896484, 1.000002384185791, 12.598062515258789),
    [9] = Vector3.new(-4.978450775146484, 1.000002384185791, 3.534541130065918),
    [10] = Vector3.new(-5.409856796264648, 1.000002384185791, 15.786935806274414),
    [11] = Vector3.new(0.972109854221344, 1.000002384185791, 4.469466209411621),
    [12] = Vector3.new(0.5568086504936218, 1.000002384185791, 15.585416793823242),
    [13] = Vector3.new(3.0137152671813965, 1.000002384185791, 13.398378372192383),
    [14] = Vector3.new(3.6143133640289307, 1.000002384185791, 7.1100592613220215),
    [15] = 'force level 3'
}

local lastac = tick()

function startgame()
    local args = {
        [1] = "Multiplayer",
        [2] = "v2:start",
        [3] = {
            ["count"] = 1,
            ["mode"] = "badlands"
        }
    }
    game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
    spawn(function ()
        wait(7.5)
        game:GetService("TeleportService"):Teleport(3260590327)
    end)
end

local lvl = game.Players.LocalPlayer:WaitForChild('Level')
if not lvl then
    wait(3)
    lvl = game.Players.LocalPlayer:FindFirstChild('Level')
    if not lvl then
        while wait(3) do
            game:GetService("TeleportService"):Teleport(3260590327)
        end
    end
end

local towers = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/roblox%20tds%20towers%20json'))()
local totowers42 = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/roblox%20tds%20cliff%20towers'))()
local huesositowers52 = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/roblox%20tds%20locked%20towers'))()
local plan = loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/roblox%20tds%20towers%20json'))()
for i,v in {plan,towers} do
    for tower,data in pairs(v) do
        local ct = totowers42[tower]
        if ct == 1 then
            data.Typerakdot = 'Cliff'
        else
            data.Typerakdot = 'Ground'
        end
        data.Namerakdot = tower
        local prev =  (data['Properties'] and data['Properties']['Price'] and data['Properties']['Price']['PreviewText']) or nil
        if prev then
            local firstNumber = prev.match(prev, "%d+")
            if firstNumber then
                data.LVLTOBUYrakdot = tonumber(firstNumber)
            else
                data.LVLTOBUYrakdot = 0
            end
        else
            data.LVLTOBUYrakdot = 0
        end
    end
    end
local owned_troops = {}
local current_hand = {}
local not_owned_troops = {}

game:GetService("Players").LocalPlayer.PlayerGui:WaitForChild('Interface')
wait(2)
if not game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild('Interface') then
    startgame()
    while wait(3) do
    end
end

for i,v in ipairs(game:GetService("Players").LocalPlayer.PlayerGui.Interface.Root.Inventory.View.Frame.Frame.Frame.Layout.Panel.InventoryScroller:GetDescendants()) do
    local spl = v.Name:split(":")
    if spl then
        if #spl == 2 then
            spl[2] = tostring(spl[2])
            spl[1] = tostring(spl[1])
            if spl[1] == 'Troop' then
                local states = v.States
                if states.Equipped.Visible then print(5)
                    current_hand[spl[2]] = 1
                    owned_troops[spl[2]] = 1
                else
                    if states.Locked.Visible then
                        not_owned_troops[spl[2]] = 1
                    else
                        owned_troops[spl[2]] = 1
                    end
                end
            end
        end
    end
end

for i,v in pairs(owned_troops) do
    print('owned: ',i)
end
for sa=1,25 do
for i,v in pairs(plan) do
    if table.find(huesositowers52,v.Namerakdot) or owned_troops[v.Namerakdot] or not (v['Properties'] and v['Properties']['Price'] and v['Properties']['Price']['Value']) then
        plan[i] = nil
        print('removing ',v.Namerakdot)
    elseif v.LVLTOBUYrakdot > lvl.Value then
        plan[i] = nil
        print('removingLVL ',v.Namerakdot)
    end
end
end
for i,v in pairs(plan) do
    print('plan: ',v.Namerakdot)
end
function checkplan()
    if buy_things_allowed then
        for i,v in pairs(plan) do
            if coins() >= v.Properties.Price.Value then
            makefolder('rakdot') 
            local lp = game.Players.LocalPlayer.Name
            makefolder('rakdot\\'..lp)
            writefile('rakdot\\'..lp..'\\buy.tower.rakdot', i)
            writefile('rakdot\\'..lp..'\\RETURN.rakdot', 'yo yo')
            warn('buying ',i)
            wait(0.1)
            game:GetService("TeleportService"):Teleport(3260590327)
            return true
            end
        end
    end     
end

spawn(function()
    while wait(0.25) do
        if checkplan() then break end
    end
end)
function upg(tower,lel)
    warn('upg')
    local args = {
        [1] = "Troops",
        [2] = "Upgrade",
        [3] = "Set",
        [4] = {
            ["Troop"] = tower,
            ["Path"] = 1
        }
    }
    wait(0.1)
    lastac = tick()
    local await = game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
    print(await)
    print('upg tower ',lel)
    wait(0.1)
end
local function lvl(tower)
    local objects = tower.Upgrades:GetChildren()
    local sorted = table.create(#objects)
    for i, obj in ipairs(objects) do
        sorted[i] = obj
    end
    table.sort(sorted, function(a, b)
        return tonumber(a.Name) < tonumber(b.Name)
    end)

    for i, obj in ipairs(sorted) do
        local allTransparent = true

        for _, desc in ipairs(obj:GetDescendants()) do
            if desc:IsA("BasePart") and desc.Transparency < 1 then
                allTransparent = false
                break
            end
        end

        if allTransparent then
            if i > 1 then
                return sorted[i - 1].Name
            else
                return nil
            end
        end
    end

    if #sorted > 0 then
        return tonumber(sorted[#sorted].Name)
    else
        return nil
    end
end
local psyh_towers = workspace.Towers
local target_lvl = 0
local towercost = 700
local lvlcosts = {
    ['1'] = 200,
    ['2'] = 900,
    ['3'] = 2750
}

local function bal()
    local bal = game:GetService("Players").LocalPlayer.PlayerGui.ReactUniversalHotbar.Frame.values.cash.amount.Text:gsub('%$',''):gsub(',','')
    local cash = tonumber(bal)
    return cash
end

function do_upg()
    local levels = {}
    for i,v in ipairs(psyh_towers:GetChildren()) do
        local got = lvl(v)
        if got then
            levels[i] = tonumber(got)
        end
    end
    warn('Good time for upg!')
    for i,v in ipairs(psyh_towers:GetChildren()) do
        if levels[i] < target_lvl then
            warn('checks level: ',levels[i])
            warn('target level: ',target_lvl)
            for ie = levels[i]+1, target_lvl do
                while bal() < lvlcosts[tostring(ie)] or tick()-lastac < 2 do
                    wait(0.1)
                end
                warn('bal: ',bal())
        warn('lvlcost: ',lvlcosts[tostring(i)])
        warn('tick-lastac: ',tick()-lastac)
                upg(v,ie)
                wait(0.1)
            end
        end
    end
end

psyh_towers.ChildAdded:Connect(function(tower)
    if target_lvl == 0 then
        return
    end
    for i = 1, target_lvl do
        while bal() < lvlcosts[tostring(i)] or tick()-lastac < 2 do
            wait(0.1)
        end
        warn('bal: ',bal())
        warn('lvlcost: ',lvlcosts[tostring(i)])
        warn('tick-lastac: ',tick()-lastac)
        upg(tower,i)
        wait(0.1)
    end
end)

local args = {
    [1] = "Voting",
    [2] = "Skip"
}
game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))

spawn(function ()
    while wait(1) do
        if not game:GetService("Players").LocalPlayer.PlayerGui.ReactGameRewards.Frame.gameOver.Visible then
            for i=1,5 do
            wait(3) if game:GetService("Players").LocalPlayer.PlayerGui.ReactGameRewards.Frame.gameOver.Visible then continue end
            end
            local args = {
                [1] = "Voting",
                [2] = "Skip"
            }
            game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
        else
            if checkplan() then break end
            startgame()
            while wait(3) do
            end
        end
    end
end)

for i,pos in pairs(things) do
    if target_lvl ~= 0 then
        do_upg()
    end
    if i == 3 then
        target_lvl = 1
        do_upg()
    elseif i == 6 then
        target_lvl = 2
        do_upg()
    elseif i == 15 then
        target_lvl = 3
        do_upg()
    else
        while bal() < towercost or tick()-lastac < 2 do
            wait(0.1)
        end
        warn('bal: ',bal())
        warn('tick-lastac: ',tick()-lastac)
        local args = {
            [1] = "Troops",
            [2] = "Pl\208\176ce",
            [3] = {
                ["Rotation"] = CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0),
                ["Position"] = pos
            },
            [4] = "Militant"
        }
        wait(0.1)
        lastac = tick()
        local await = game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
        print('Placing tower ',await)
        wait(0.1)
    end
end

end

while not game.IsLoaded(game) do wait() end

makefolder('rakdot') 
local lp = game.Players.LocalPlayer.Name
makefolder('rakdot\\'..lp)

if isfile('rakdot\\webhook.txt') then
    getgenv().rakdot_WebhookUrl = tostring(readfile('rakdot\\webhook.txt'))
    webhook={}
    
    function webhook:send(content, embedColor)
        if content then
            content = '['..lp..']:>-'..[[
                
            ]]..content
        end
        local url = getgenv().rakdot_WebhookUrl 
        if embedColor == 'green' then
            embedColor = 65280
        elseif embedColor == 'red' then
            embedColor = 16711680
        elseif embedColor == 'blue' then
            embedColor = 65535
        elseif embedColor == 'yellow' then
            embedColor = 16776960
        end
        local color = embedColor or 8421504
        request({
            Url = url,
            Method = 'POST',
            Headers = {
                ['Content-Type'] = 'application/json'
            },
            Body = game:GetService("HttpService"):JSONEncode({
                embeds = {{
                    description = content or "No content",
                    color = color -- Discord expects decimal color
                }}
            })
        })
    end
else
    webhook = {}
    function webhook:send(a,b)
        return
    end
end
    game.Players.PlayerRemoving:Connect(function (plr)
    if plr.Name == game.Players.LocalPlayer.Name then
        webhook:send('Leaving current place')
    end
end)

spawn(function ()
    -- Coins tracking
    local ciuns = game.Players.LocalPlayer:WaitForChild('Coins')
    if not ciuns then
        wait(3)
        ciuns = game.Players.LocalPlayer:FindFirstChild('Coins')
        if not ciuns then
            while wait(3) do
                game:GetService("TeleportService"):Teleport(3260590327)
            end
        end
    end
    local balbef
    if isfile('rakdot\\'..lp..'\\balance.rakdot') then
        balbef = tonumber(readfile('rakdot\\'..lp..'\\balance.rakdot'))
    end
    local cv = ciuns.Value
    if balbef then
        if cv ~= balbef then
            if cv > balbef then
                webhook:send('Gained money: '..cv-balbef..[[$
Balance: ]]..cv..'$','yellow')
            else
                webhook:send('Spent money: '..math.abs(cv-balbef)..[[$
Balance: ]]..cv..'$','yellow')
            end
        end
    end
    writefile('rakdot\\'..lp..'\\balance.rakdot',tostring(cv))

    -- Level tracking
    local lvl = game.Players.LocalPlayer:WaitForChild('Level')
    if not lvl then
        wait(3)
        lvl = game.Players.LocalPlayer:FindFirstChild('Level')
        if not lvl then
            while wait(3) do
                game:GetService("TeleportService"):Teleport(3260590327)
            end
        end
    end
    local lvlbef
    if isfile('rakdot\\'..lp..'\\level.rakdot') then
        lvlbef = tonumber(readfile('rakdot\\'..lp..'\\level.rakdot'))
    end
    local lvlcv = lvl.Value
    if lvlbef then
        if lvlcv ~= lvlbef then
            webhook:send('Level increased: '..lvlcv,'blue')
        end
    end
    writefile('rakdot\\'..lp..'\\level.rakdot',tostring(lvlcv))
end)

local lvl = game.Players.LocalPlayer:WaitForChild('Level')
if not lvl then
    wait(3)
    lvl = game.Players.LocalPlayer:FindFirstChild('Level')
    if not lvl then
        while wait(3) do
            game:GetService("TeleportService"):Teleport(3260590327)
        end
    end
end
local place = ''

spawn(function ()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/hassanxzayn-lua/Anti-afk/main/antiafkbyhassanxzyn"))();
end)

local kickwebhooked = false

spawn(function() -- auto reconect
    local last_contact = tick()
    spawn(function() while wait(3) do
        local  a = game.ReplicatedStorage.RemoteFunction:InvokeServer()
        last_contact = tick() end
    end)
    while wait(1) do
        if tick()-last_contact > 20 then
            if not kickwebhooked then
                kickwebhooked = true
                webhook:send('Disconnected','red')
            end
            warn('No connection, auto rejoining when its possible')
            game:GetService("TeleportService"):Teleport(3260590327)
            else
            if tick()-last_contact < 6 then
                --print('Connection is okay!')
            else
                warn('Connection is not detected last time')
            end
        end
    end
end)

if tonumber(game.PlaceId) == 3260590327 then
	place = 'lobby'
else
	place = 'game'
end

local hts = game:GetService('HttpService')
if place == 'lobby' then
    webhook:send('In lobby','green')
    local args = {
        [1] = "Tutorial",
        [2] = "Complete"
    }
    game:GetService("ReplicatedStorage").RemoteEvent:FireServer(unpack(args))
    wait()
    game:GetService("ReplicatedStorage").Network.DailySpin:FindFirstChild("RF:RedeemReward"):InvokeServer()
    wait(1)
    game:GetService("ReplicatedStorage").Network.DailySpin:FindFirstChild("RF:RedeemSpin"):InvokeServer()
    wait()
    makefolder('rakdot') 
local lp = game.Players.LocalPlayer.Name
makefolder('rakdot\\'..lp)
    if isfile('rakdot\\'..lp..'\\buy.tower.rakdot') then
        local tower = tostring(readfile('rakdot\\'..lp..'\\buy.tower.rakdot'))
        warn('buying2 ',tower)
        wait(0.1)
        delfile('rakdot\\'..lp..'\\buy.tower.rakdot')
        local args = {
            [1] = "Shop",
            [2] = "Purchase",
            [3] = "tower",
            [4] = tower
        }
        game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
        webhook:send('Tried to buy tower `'..tower..'`','green')
        wait(1)
    end
    wait(1)
    if lvl.Value < 25 then
        warn('LOW LVL!')
        local dif
        if lvl.Value >= 30 then
            dif = 'Fallen'
        elseif lvl.Value >= 15 then
            dif = 'Molten'
        elseif lvl.Value >= 5 then
            dif = 'Intermediate'
        else
            dif = 'Easy'
        end
        warn('difficulty: ',dif)
        local cfg = {
            MM = {
                difficulty = dif,
                Count = 1,
                Mode = 'survival'
            }
        }
            local args = {
                [1] = "Multiplayer",
                [2] = "v2:start",
                [3] = {
                    ["difficulty"] = cfg.MM.difficulty,
                    ["count"] = cfg.MM.Count,
                    ["mode"] = cfg.MM.Mode
                }
            }
            
            game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
        else
            local args = {
                [1] = "Inventory",
                [2] = 'Unequip',
                [3] = "tower",
                [4] = 'Militant'
            }
            
            game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
            wait(1)
            
            local args = {
                [1] = "Inventory",
                [2] = 'Equip',
                [3] = "tower",
                [4] = 'Militant'
            }
            
            game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
            wait(1)
            local args = {
                [1] = "Multiplayer",
                [2] = "v2:start",
                [3] = {
                    ["count"] = 1,
                    ["mode"] = "badlands"
                }
            }
            game:GetService("ReplicatedStorage").RemoteFunction:InvokeServer(unpack(args))
    end
else
    wait(1)
   if workspace:FindFirstChild('Map') and workspace.Map:FindFirstChild('Environment') and workspace.Map.Environment:FindFirstChild('Train') and #workspace.Map.Environment:FindFirstChild('Train'):GetChildren() == 6 then
    webhook:send('Loading ab','green')
    loadscript_ab()
   else
    webhook:send('Loading amp','green')
    loadscript_amp()
   end
end

end)
if not sucka then
local ran = math.random(1000000,9999999)
if webhook then
pcall(function()
webhook:send('Error occured! file: error_log_'..ran)
end)
end
local data = {error=reska}
writefile('rakdot\\error_log_'..ran..'.txt',game.HttpService:JSONEncode(data))
wait(1)
game:GetService("TeleportService"):Teleport(3260590327)
end

end

local queueteleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
local TeleportCheck = false
game.Players.LocalPlayer.OnTeleport:Connect(function(State)
	if (not TeleportCheck) and queueteleport then
		TeleportCheck = true
		queueteleport([[loadstring(game:HttpGet('https://raw.githubusercontent.com/VANKApidarnoi/trash/refs/heads/main/ikebaba'))()]])
	end
end)

SCRIPT()